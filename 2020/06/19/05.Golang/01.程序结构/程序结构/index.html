<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Golang程序结构 | 
	 
	黑月骑马
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">黑月骑马</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/heiyueqima" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar" >
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc" >
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.KVM
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.KVM安装
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/15/01.KVM/01.KVM%E5%AE%89%E8%A3%85/1.kvm%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/">
										1.kvm的简单安装
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02.Kubernetes
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.kubernetes安装部分
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.kubernetes使用adm安装
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/17/02.Kubernetes/01.kubernetes%E5%AE%89%E8%A3%85%E9%83%A8%E5%88%86/01.kubernetes%E4%BD%BF%E7%94%A8adm%E5%AE%89%E8%A3%85/01.Kubeadm%E5%AE%89%E8%A3%85kubernetes%E9%9B%86%E7%BE%A4/">
										01.Kubeadm安装kubernetes集群
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02.kubernetes使用RKE安装
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/15/02.Kubernetes/01.kubernetes%E5%AE%89%E8%A3%85%E9%83%A8%E5%88%86/02.kubernetes%E4%BD%BF%E7%94%A8RKE%E5%AE%89%E8%A3%85/1.RKE%E5%AE%89%E8%A3%85Kubernetes%E9%9B%86%E7%BE%A4/">
										1.RKE安装Kubernetes集群
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/15/02.Kubernetes/01.kubernetes%E5%AE%89%E8%A3%85%E9%83%A8%E5%88%86/02.kubernetes%E4%BD%BF%E7%94%A8RKE%E5%AE%89%E8%A3%85/2.Rancher%E5%AE%89%E8%A3%85/">
										2.Rancher安装
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/17/02.Kubernetes/01.kubernetes%E5%AE%89%E8%A3%85%E9%83%A8%E5%88%86/02.kubernetes%E4%BD%BF%E7%94%A8RKE%E5%AE%89%E8%A3%85/3.Rancher%E6%96%87%E6%A1%A3%E6%91%98%E5%BD%95/">
										3.Rancher文档摘录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/15/02.Kubernetes/01.kubernetes%E5%AE%89%E8%A3%85%E9%83%A8%E5%88%86/02.kubernetes%E4%BD%BF%E7%94%A8RKE%E5%AE%89%E8%A3%85/4.Rancher%E7%AB%AF%E5%8F%A3/">
										4.Rancher端口
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02.kubernetes基础知识
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/22/02.Kubernetes/02.kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1/">
										01.kubernetes基础知识-1
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										05.kubernetes常用服务
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/15/02.Kubernetes/05.kubernetes%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1/01.Mongodb%E7%9A%84%E5%89%AF%E6%9C%AC%E9%9B%86/">
										01.Mongodb的副本集
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/16/02.Kubernetes/05.kubernetes%E5%B8%B8%E7%94%A8%E6%9C%8D%E5%8A%A1/02.cephfs%E7%9A%84%E5%AE%89%E8%A3%85/">
										02.cephfs的安装
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										07.kubernetes业务搭建
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/16/02.Kubernetes/07.kubernetes%E4%B8%9A%E5%8A%A1%E6%90%AD%E5%BB%BA/01.rocket.chat%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/">
										01.rocket.chat聊天系统搭建
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03.python
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.数据结构与算法python版本
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/29/03.python/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python%E7%89%88%E6%9C%AC/1.python%E5%85%A5%E9%97%A8/">
										1.python入门
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										04.ceph
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.ceph储存架构
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/06/06/04.ceph/01.ceph%E5%82%A8%E5%AD%98%E6%9E%B6%E6%9E%84/01.ceph%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84/">
										01.ceph存储架构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										05.Golang
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/06/19/05.Golang/00.Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">
										00.Go语言圣经思维导图
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01.程序结构
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2020/06/19/05.Golang/01.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/">
										程序结构
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02.数据类型
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/06/21/05.Golang/02.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
										数据类型
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	程序结构
</h1>
<div class="article-meta">
	
	<span>HeiYueQiMa</span>
	<span>2020-06-19 04:21:25</span>
    
		<div id="article-categories">
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/Golang/">Golang</a>
						
							>
						
                    </span>
                
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true"></i>
                        <a href="/categories/Golang/编程/">编程</a>
						
                    </span>
                
            
		</div>
    
</div>

<div id="article-content">
	<h2 id="1-命名"><a href="#1-命名" class="headerlink" title="1.命名"></a>1.命名</h2><p>Go语⾔中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循⼀个简单的命名规则：⼀个名字必须以⼀个字⺟（Unicode字⺟）或下划线开头，后⾯可以跟任意数量的字⺟、数字或下划线。⼤写字⺟和⼩写字⺟是不同的</p>
<blockquote>
<p>Go语言共有25个关键字</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>default</td>
<td>func</td>
<td>interface</td>
<td>select</td>
</tr>
<tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>false</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<blockquote>
<p>还有30多个预定义的名字 主要对应内建的常量、类型和函数</p>
</blockquote>
<p>这些内部预先定义的名字并不是关键字 可以在定义中使用 但是也要避免过度使用引起语义混乱</p>
<pre><code>内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error

内建函数: make len cap new append copy close delete
complex real imag
panic recover</code></pre><p><strong>如果⼀个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有⽂件中都可以访问。名字的开头字⺟的⼤⼩写决定了名字在包外的可⻅性。名字开头为大写字母外部包可以调用。名字开头小写字母就是不可调用的。</strong></p>
<p>名字的⻓度没有逻辑限制，但是Go语⾔的⻛格是尽量使⽤短⼩的名字。推荐使⽤ 驼峰式 命名，当名字由⼏个单词组成时优先使⽤⼤⼩写分隔。</p>
<h2 id="2-声明"><a href="#2-声明" class="headerlink" title="2.声明"></a>2.声明</h2><p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语⾔主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声名。</p>
<p>在包⼀级声明语句声明的名字可在整个包对应的每个源⽂件中访问，⽽不是<br>仅仅在其声明语句所在的源⽂件中访问。</p>
<p>⼀个函数的声明由⼀个函数名字、参数列表（由函数的调⽤者提供参数变量的具体值）、⼀个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。</p>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><p>变量语法</p>
<pre><code>var 变量名字 类型 = 表达式</code></pre><p>其中“类型”或“= 表达式”两个部分可以省略其中的⼀个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将⽤零值初始化该变量。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认零值</th>
</tr>
</thead>
<tbody><tr>
<td>数值类型</td>
<td>0</td>
</tr>
<tr>
<td>布尔变量类型</td>
<td>false</td>
</tr>
<tr>
<td>字符串类型</td>
<td>“”</td>
</tr>
<tr>
<td>接口</td>
<td>nil</td>
</tr>
<tr>
<td>slice</td>
<td>nil</td>
</tr>
<tr>
<td>指针</td>
<td>nil</td>
</tr>
<tr>
<td>map</td>
<td>nil</td>
</tr>
<tr>
<td>chan</td>
<td>nil</td>
</tr>
<tr>
<td>函数</td>
<td>nil</td>
</tr>
</tbody></table>
<p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值,因此go语言不存在未初始化的值。</p>
<h3 id="3-1-简短变量声明"><a href="#3-1-简短变量声明" class="headerlink" title="3.1 简短变量声明"></a>3.1 简短变量声明</h3><p>在函数内部，有⼀种称为简短变量声明语句的形式可⽤于声明和初始化局部变量。它以“名字 :=表达式”形式声明变量，变量的类型根据表达式来⾃动推导</p>
<pre><code class="golang">anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
i, j := 0, 1</code></pre>
<p>和普通var形式的变量声明语句⼀样，简短变量声明语句也可以⽤函数的返回值来声明和初始化变量.</p>
<pre><code class="golang">f, err := os.Open(name)
if err != nil {
  return err
}
// ...use f...
f.Close()</code></pre>
<p>简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有⼀些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值⾏为.</p>
<pre><code class="golang">var err error 
f,err := os.Open(name)
if err != nil {
  return err
}
f.Close()</code></pre>
<p>简短变量声明语句中必须⾄少要声明⼀个新的变量 下面这种方式是不合法的 </p>
<pre><code>var f interface 
var err  error 
f,err := os.Open(name)</code></pre><p>简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明⼀个新的变量。这个例子会提示main函数的err没有使用。</p>
<pre><code class="golang">package main

import (
    &quot;log&quot;
    &quot;os&quot;
)


func main() {
    var err error
    l12()
}


func l12(){
    f,err := os.Open(&quot;&quot;)
    if err!= nil {
        log.Fatal(err)
    }
    f.Close()
}
</code></pre>
<h3 id="3-2-指针"><a href="#3-2-指针" class="headerlink" title="3.2 指针"></a>3.2 指针</h3><p>⼀个指针的值是另⼀个变量的地址。⼀个指针对应变量在内存中的存储位置。并不是每⼀个值都会有⼀个内存地址，但是对于每⼀个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，⽽不需要知道该变量的名字。</p>
<p>如果⽤“var x int”声明语句声明⼀个x变量，那么&amp;x表达式（取x变量的内存地址）将产⽣⼀个指向该整数变量的指针，指针对应的数据类型是 *int ，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时 *p 表达式对应p指针指向的变量的值.</p>
<pre><code class="golang">x := 1
p := &amp;x // p, of type *int, points to x
fmt.Println(*p) // &quot;1&quot;
*p = 2 // equivalent to x = 2
fmt.Println(x)</code></pre>
<p>对于聚合类型每个成员——⽐如结构体的每个字段、或者是数组的每个元素——也都是对应⼀<br>个变量，因此可以被取地址。变量有时候被称为可寻址的值。即使变量由表达式临时⽣成，那么表达式也必须能接受 &amp; 取地址操作。</p>
<p>任何类型的指针的零值都是nil。如果p指向某个有效变量，那么 p != nil 测试为真。指针之间<br>也是可以进⾏相等测试的，只有当它们指向同⼀个变量或全部是nil时才相等。</p>
<pre><code class="golang">var x, y int
fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil)</code></pre>
<p>返回函数中局部变量的地址也是安全的。</p>
<pre><code class="golang">var p = f()
func f() *int {
  v := 1
  return &amp;v
}</code></pre>
<p>因为指针包含了⼀个变量的地址，因此如果将指针作为参数调⽤函数，那将可以在函数中通过该指针来更新变量的值.</p>
<pre><code class="golang">func incr(p *int) int {
*p++ // ⾮常重要：只是增加p指向的变量的值，并不改变p指针！！！
return *p
}
v := 1
incr(&amp;v) // side effect: v is now 2
fmt.Println(incr(&amp;v)) // &quot;3&quot; (and v is 3)</code></pre>
<p>每次我们对⼀个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如， *p 就是变量v的别名。指针特别有价值的地⽅在于我们可以不⽤名字⽽访问⼀个变量，但是这是⼀把双刃剑：要找到⼀个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语⾔的垃圾回收器所做的⼯作）。不仅仅是指针会创建别名，很多其他引⽤类型也会创建别名，例如slice、map和chan，甚⾄结构体、数组和接⼝都会创建所引⽤变量的别名。</p>
<h3 id="3-3-new函数"><a href="#3-3-new函数" class="headerlink" title="3.3 new函数"></a>3.3 new函数</h3><p>另⼀个创建变量的⽅法是调⽤内建的new函数。表达式new(T)将创建⼀个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T。</p>
<p>⽤new创建变量和普通变量声明语句⽅式创建变量没有什么区别，除了不需要声明⼀个临时变量的名字外，我们还可以在表达式中使⽤new(T)。换⾔之，new函数类似是⼀种语法糖，⽽不是⼀个新的基础概念。</p>
<pre><code class="golang">p := new(int) // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // &quot;0&quot;
*p = 2 // 设置 int 匿名变量的值为 2
fmt.Println(*p)

// new相当于省略了 命名的部分 直接设置别名

var z int 
zptr := &amp;z 
fmt.Println(*zptr)
*zptr = 2 
fmt.Println(*zptr)</code></pre>
<p>每次调用new函数都是返回一个新的变量地址,因此他们是不同的变量，比较内存地址的话肯定是不相同的，比较值是相同的。</p>
<pre><code class="golang">a,b := new(int),new(int)

c := a == b 
d := *a == *b

fmt.Println(c) //false 
fmt.Println(d) //true </code></pre>
<blockquote>
<p>注意事项:</p>
</blockquote>
<p>当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的⼤⼩是0，例如 struct{} 和 [0]int ，有可能有相同的地址（依赖具体的语⾔实现）（译注：请谨慎使⽤⼤⼩为0的类型，因为如果类型的⼤⼩为0的话，可能导致Go语⾔的⾃动垃圾回收器有不同的⾏为，具体请查看 runtime.SetFinalizer 函数相关⽂档</p>
<h3 id="3-4-变量的生命周期"><a href="#3-4-变量的生命周期" class="headerlink" title="3.4 变量的生命周期"></a>3.4 变量的生命周期</h3><p>变量的⽣命周期指的是在程序运⾏期间变量有效存在的时间段。<strong>对于在包⼀级声明的变量来说，它们的⽣命周期和整个程序的运⾏周期是⼀致的</strong></p>
<p>局部变量的⽣命周期则是动态的：每次从创建⼀个新变量的声明语句开始，直到该变量不再被引⽤为⽌，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调⽤的时候创建。</p>
<p>Go语⾔的⾃动垃圾收集器是如何知道⼀个变量是何时可以被回收的呢？这⾥我们可以避开<br>完整的技术细节，基本的实现思路是，<strong>从每个包级的变量和每个当前运⾏函数的每⼀个局部变量开始，通过指针或引⽤的访问路径遍历，是否可以找到该变量。</strong> 如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>
<p>因为⼀个变量的有效周期只取决于是否可达，因此⼀个循环迭代内部的局部变量的⽣命周期可能超出其局部作⽤域。同时，局部变量可能在函数返回之后依然存在。可以通过函数返回值和指针的方式。</p>
<pre><code class="golang">var global *int
func f(){
  var x int 
  x = 1
  global = &amp;x 
}

func g(){
  y := new(int)
  *y = 1
}</code></pre>
<p><strong>f函数⾥的x变量必须在堆上分配，因为它在函数退出后依然可以通过包⼀级的global变量找到，虽然它是在函数内部定义的；⽤Go语⾔的术语说，这个x局部变量从函数f中逃逸了</strong> </p>
<p><strong>当g函数返回时，变量 *y 将是不可达的，也就是说可以⻢上被回收的。因此， *y 并没有从函数g中逃逸，编译器可以选择在栈上分配 *y 的存储空间</strong> </p>
<p>（译注：也可以选择在堆上分配，然后由Go语⾔的GC回收这个变量的内存空间），虽然这⾥⽤的是new⽅式。其实在任何时候，你并不需为了编写正确的代码⽽要考虑变量的逃逸⾏为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产⽣细微的影响。</p>
<p>Go语⾔的⾃动垃圾收集器对编写正确的代码是⼀个巨⼤的帮助，但也并不是说你完全不⽤考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写⾼效的程序你依然需要了解变量的⽣命周期。例如，如果将指向短⽣命周期对象的指针保存到具有⻓⽣命周期的对象中，特别是保存到全局变量时，会阻⽌对短⽣命周期对象的垃圾回收（从⽽可能影响程序的性能）.</p>
<h2 id="4-赋值"><a href="#4-赋值" class="headerlink" title="4.赋值"></a>4.赋值</h2><p>使⽤赋值语句可以更新⼀个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边.</p>
<p>特定的⼆元算术运算符和赋值语句的复合操作有⼀个简洁形式</p>
<pre><code class="golang">count[x] = count[x] * 2
//可以重写成下面这种方式
count[x] *= 2

//也支持 ++ -- 操作语句
v := 1
v++ //等价于 v = v + 1 
v-- //等价于 v = v - 1</code></pre>
<h3 id="4-1-元组赋值"><a href="#4-1-元组赋值" class="headerlink" title="4.1 元组赋值"></a>4.1 元组赋值</h3><p>元组赋值是另⼀种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进⾏求值，然后再统⼀更新左边对应变量的值。<strong>可以用于交换2个变量</strong></p>
<pre><code class="golang">x,y = y,x
a[i],b[j] = a[j],a[i]</code></pre>
<ul>
<li>计算斐波那契数列</li>
</ul>
<pre><code class="golang">func fib(n int) (int, *[]uint64) {
    var list []uint64
    x, y := 0, 1
    list = append(list, uint64(x), uint64(y))
    for i := 0; i &lt; n; i++ {
        x, y = y, x+y
        list = append(list, uint64(y))
    }
    return x, &amp;list
}</code></pre>
<ul>
<li>元组赋值也可以使⼀系列琐碎赋值更加紧凑</li>
</ul>
<p>如果表达式太复杂的话，尽量避免使用元祖赋值，因为每个变量单独赋值语句的写法可读性会更好。</p>
<pre><code class="golang">i,j,k = 2,3,5</code></pre>
<p>有些表达式会产⽣多个值，⽐如调⽤⼀个有多个返回值的函数。当这样⼀个函数调⽤出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数⽬必须和右边⼀致。</p>
<pre><code class="golang">f,err := os.Open(&quot;name.txt&quot;)
// 这个err代表某种错误类型。还有一些是用来返回布尔型，通常被称为ok
v, ok = m[key] // 可以用于map内查找，map查找失败会返回零值
v, ok = x.(T)  // 用于类型断言 类型断言失败会产生panic异常
v, ok = &lt;-ch   // 用于信道接收信息 通道失败的是会返回nil</code></pre>
<blockquote>
<p>注意事项</p>
</blockquote>
<p>map查找、类型断言、通道接收 出现在赋值语句的右边，并不一定时产生2个结果，也可能产生一个结果。也可以用 _ 空白标识符 丢弃不需要的值</p>
<pre><code class="golang">v = m[key]      // map查找，失败时返回零值
v = x.(T)       // type断⾔，失败时panic异常
v = &lt;-ch        // 管道接收，失败时返回零值（阻塞不算是失败）
_, ok = m[key]  // map返回2个值
_, ok = mm[&quot;&quot;], false // map返回1个值
_ = mm[&quot;&quot;]      // map返回1个值</code></pre>
<h3 id="4-2-可赋值性"><a href="#4-2-可赋值性" class="headerlink" title="4.2 可赋值性"></a>4.2 可赋值性</h3><p>赋值语句是显式的赋值形式，但是程序中还有很多地⽅会发⽣隐式的赋值⾏为：函数调⽤会隐式地将调⽤参数的值赋值给函数的参数变量，⼀个返回语句会隐式地将返回操作的值赋值给结果变量。</p>
<pre><code class="golang">//显式赋值
medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}

//隐式赋值
medals[0] = &quot;gold&quot;
medals[1] = &quot;silver&quot;
medals[2] = &quot;bronze&quot;</code></pre>
<p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。不管是隐式还是显式的赋值方式，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类。</p>
<p>可赋值性的规则对于不同类型有着不同要求，简单的赋值规则。</p>
<ul>
<li><p>类型匹配</p>
</li>
<li><p>nil可以赋值给任何指针或者引用类型</p>
</li>
</ul>
<h2 id="5-类型"><a href="#5-类型" class="headerlink" title="5.类型"></a>5.类型</h2><p>变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储⼤⼩（或者是元素<br>的bit个数），它们在内部是如何表达的，是否⽀持⼀些操作符，以及它们⾃⼰关联的⽅法集<br>等。</p>
<p><strong>在任何程序中都会存在⼀些变量有着相同的内部结构，但是却表示完全不同的概念。</strong></p>
<p>⼀个类型声明语句创建了⼀个新的类型名称，和现有类型具有相同的底层结构。新命名的类型<br>提供了⼀个⽅法，⽤来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>
<pre><code class="golang">type 类型名字 底层类型</code></pre>
<p>类型声明语句⼀般出现在包⼀级，因此如果新创建的类型名字的⾸字符⼤写，则在包外部也可<br>以使⽤。</p>
<pre><code class="golang">package tempconv
import &quot;fmt&quot;

type Celsius float64 // 摄⽒温度
type Fahrenheit float64 // 华⽒温度

/*
  Celsius和Fahrenheit分别对应不同的温度单位。

  它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互⽐较或混在⼀个表达式运算.

  可以避免⼀些像⽆意中使⽤不同单位的温度混合计算导致的错误.
*/

const (
  AbsoluteZeroC Celsius = -273.15 // 绝对零度
  FreezingC Celsius = 0 // 结冰点温度
  BoilingC Celsius = 100 // 沸⽔温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }</code></pre>
<p>对于每⼀个类型T，都有⼀个对应的类型转换操作T(x)，⽤于将x转为T类型（译注：如果T是指针类型，可能会需要⽤⼩括弧包装T，⽐如 (*int)(0) )。</p>
<p>只有当两个类型的<strong>底层基础类型相同时</strong>，才允许这种转型操作，或者是两者都是指向<strong>相同底层结构的指针类型</strong>，这些转换只改变类型⽽不会影响值本身。</p>
<p>数值类型之间的转型也是允许的，并且在字符串和⼀些特定类型的slice之间也是可以转换的,这类转换可能改变值的表现。将⼀个浮点数转为整数将丢弃⼩数部分，将⼀个字符串转为 []byte 类型的slice将拷⻉⼀个字符串数据的副本。</p>
<p><strong>底层数据类型决定了内部结构和表达⽅式，也决定是否可以像底层类型⼀样对内置运算符的⽀持</strong>。这意味着，Celsius和Fahrenheit类型的<strong>算术运算⾏为和底层的float64类型是⼀样的</strong>。</p>
<pre><code class="golang">/*
⽐较运算符 == 和 &lt; 也可以⽤来⽐较⼀个命名类型的变量和另⼀个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做⽐较。但是如果两个值有着不同的类型，则不能直接进⾏⽐较。
*/
var c Celsius
var f Fahrenheit
fmt.Println(c == 0) // &quot;true&quot;
fmt.Println(f &gt;= 0) // &quot;true&quot;
fmt.Println(c == f) // compile error: type mismatch
fmt.Println(c == Celsius(f)) // &quot;true&quot;! 这里的Celsius(f)是类型转换不是函数调用

func (c Celsius) String() string { return fmt.Sprintf(&quot;%g°C&quot;, c) }
/*
许多类型都会定义⼀个String⽅法，因为当使⽤fmt包的打印⽅法时，将会优先使⽤该类型对应的String⽅法返回的结果打印.
*/
</code></pre>
<h2 id="6-包和文件"><a href="#6-包和文件" class="headerlink" title="6.包和文件"></a>6.包和文件</h2><p>Go语⾔中的包和其他语⾔的库或模块的概念类似，⽬的都是为了⽀持模块化、封装、单独编译<br>和代码重⽤。⼀个包的源代码保存在⼀个或多个以.go为⽂件后缀名的源⽂件中，通常⼀个包所在<strong>⽬录路径的后缀是包的导⼊路径</strong>.</p>
<p>每个包都对应⼀个独⽴的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引⽤该函数，必须显式使⽤image.Decode或utf16.Decode形式访问。</p>
<p>包还可以让我们通过控制哪些名字是外部可⻅的来隐藏内部实现信息。在Go语⾔中，⼀个简单<br>的规则是：<strong>如果⼀个名字是⼤写字⺟开头的，那么该名字是导出的</strong>（译注：因为汉字不区分⼤⼩写，因此汉字开头的名字是没有导出的）。</p>
<p>通常，包注释的第⼀句应该先是包的功能概要说明。⼀个包通常只有⼀个源⽂件有包注释（译注：如果有多个包注释，⽬前的⽂档⼯具会根据源⽂件名的先后顺序将它们链接为⼀个包注释）。如果包注释很⼤，通常会放到⼀个独⽴的doc.go⽂件中。</p>
<h3 id="6-1-导入包"><a href="#6-1-导入包" class="headerlink" title="6.1 导入包"></a>6.1 导入包</h3><ul>
<li><p>每个包都有⼀个全局唯⼀的导⼊路径。</p>
</li>
<li><p>⼀个导⼊路径代表⼀个⽬录中的⼀个或多个Go源⽂件。</p>
</li>
<li><p>除了包的导⼊路径，每个包还有⼀个包名，包名⼀般是短⼩的名字（并不要求包名是唯⼀的），包名在包的声明处指定。</p>
</li>
<li><p>⼀个包的名字和包的导⼊路径的最后⼀个字段相同。</p>
</li>
<li><p>导⼊语句将导⼊的包绑定到⼀个短⼩的名字，然后通过该短⼩的名字就可以引⽤包中导出的全部内容</p>
</li>
<li><p>如果导⼊了⼀个包，但是⼜没有使⽤该包将被当作⼀个编译错误处理。这种强制规则可以有效减少不必要的依赖。</p>
</li>
<li><p>可以为导入的包指定名字 一般在包的前面</p>
</li>
</ul>
<h3 id="6-2-包的初始化"><a href="#6-2-包的初始化" class="headerlink" title="6.2 包的初始化"></a>6.2 包的初始化</h3><p>包的初始化⾸先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化。</p>
<pre><code class="golang">var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第⼆个初始化, 为 2, 通过调⽤ f (依赖c)
var c = 1 // c 第⼀个初始化, 为 1
func f() int { return c + 1 }</code></pre>
<p>如果包中含有多个.go源⽂件，它们将按照发给编译器的顺序进⾏初始化，Go语⾔的构建⼯具⾸先会将.go⽂件根据⽂件名排序，然后依次调⽤编译器编译。</p>
<p>对于在包级别声明的变量，如果有初始化表达式则⽤表达式初始化。</p>
<p>还有⼀些没有初始化表达式的,在这种情况下，我们可以⽤⼀个<strong>特殊的init初始化函数来简化初始化⼯作。</strong></p>
<p><strong>每个⽂件都可以包含多个init初始化函数.</strong> 多个init函数的执行顺序并不是固定的。</p>
<p>这样的init初始化函数除了不能被调⽤或引⽤外，其他⾏为和普通函数类似。在每个⽂件中的init初始化函数，在程序开始执⾏时按照它们声明的顺序被⾃动调⽤。</p>
<p>每个包在解决依赖的前提下，以导⼊声明的顺序初始化，每个包只会被初始化⼀次,初始化⼯作是⾃下⽽上进⾏的，main包最后被初始化。以这种⽅式，可以确保在main函数执⾏之前，所有依赖的包都已经完成初始化⼯作了。</p>
<h2 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7.作用域"></a>7.作用域</h2><ul>
<li><p><strong>⼀个声明语句将程序中的实体和⼀个名字关联，⽐如⼀个函数或⼀个变量。声明语句的作⽤域是指源代码中可以有效使⽤这个名字的范围。</strong></p>
<ul>
<li><p>不要将作⽤域和⽣命周期混为⼀谈。<strong>声明语句的作⽤域对应的是⼀个源代码的⽂本区域；</strong> 它是⼀个编译时的属性。</p>
</li>
<li><p>⼀个变量的⽣命周期是指程序运⾏时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引⽤；是⼀个运⾏时的概念。</p>
</li>
</ul>
</li>
<li><p>句法块是由花括弧所包含的⼀系列语句，就像函数体或循环体花括弧包裹的内容⼀样。<strong>句法块内部声明的名字是⽆法被外部块访问的。</strong> </p>
<ul>
<li><p>这个块决定了内部声明的名字的作⽤域范围。</p>
</li>
<li><p>我们可以把块（block）的概念推⼴到包括其他声明的群组，这些声明在代码中<strong>并未显式地使⽤花括号包裹起来，我们称之为词法块。</strong> </p>
</li>
<li><p>全局的源代码来说，存在⼀个整体的词法块，称为全局词法块；</p>
</li>
<li><p>对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分⽀也有独⽴的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p>
</li>
</ul>
</li>
<li><p>声明语句对应的词法域决定了作⽤域范围的⼤⼩。</p>
<ul>
<li><strong>对于内置的类型、函数和常量，⽐如int、len和true等是在全局作⽤域的，因此可以在整个程序中直接使⽤。</strong> </li>
</ul>
</li>
<li><p>任何在函数外部（也就是包级语法域）声明的名字可以在同⼀个包的任何源⽂件中访问的。</p>
<ul>
<li><p>对于导⼊的包，则是对应源⽂件级的作⽤域，因此只能在当前的⽂件中访问导⼊的包，当前包的其它源⽂件⽆法访问在当前源⽂件导⼊的包。</p>
</li>
<li><p>还有许多声明语句，⽐如导入的包的函数中的变量c，则是局部作⽤域的，它只能在函数内部（甚⾄只能是局部的某些部分）访问。</p>
</li>
</ul>
</li>
<li><p><strong>控制流标号，就是break、continue或goto语句后⾯跟着的那种标号，则是函数级的作⽤域。</strong></p>
</li>
<li><p><strong>⼀个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。</strong></p>
<ul>
<li><p>当编译器遇到⼀个名字引⽤时，它会对其定义进⾏查找，查找过程从最内层的词法域向全局的作⽤域进⾏。</p>
</li>
<li><p>如果查找失败，则报告“未声明的名字”这样的错误。</p>
</li>
<li><p>如果该名字在内部和外部的块分别声明过，则内部块的声明⾸先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字⽆法被访问。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>在函数中词法域可以深度嵌套，因此内部的⼀个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。</li>
</ul>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2020/06/21/05.Golang/02.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  数据类型
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2020/06/19/05.Golang/00.Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/">
                
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2020-<span id="footerYear"></span> 
	<a href="/">HeiYueQiMa</a> 
	
	
	
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>